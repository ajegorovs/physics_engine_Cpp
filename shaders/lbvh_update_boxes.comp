/**
* VkLBVH written by Mirco Werner: https://github.com/MircoWerner/VkLBVH
* Based on:
* https://research.nvidia.com/sites/default/files/pubs/2012-06_Maximizing-Parallelism-in/karras2012hpg_paper.pdf
* https://developer.nvidia.com/blog/thinking-parallel-part-iii-tree-construction-gpu/
* https://github.com/ToruNiina/lbvh
* https://github.com/embree/embree/blob/v4.0.0-ploc/kernels/rthwif/builder/gpu/sort.h
*/
#version 460
#extension GL_GOOGLE_include_directive: enable

#include "lbvh_common.glsl"

layout (local_size_x = 256) in;

layout (std430, set = 0, binding = 1) readonly buffer elements {
    Element g_elements[];
};


// calculate morton code for each element
void main() {
    uint gID = gl_GlobalInvocationID.x;

    if (gID >= g_num_elements) {
        return;
    }

    Element element = g_elements[gID];
    vec3 aabbMin = vec3(element.aabbMinX, element.aabbMinY, element.aabbMinZ);
    vec3 aabbMax = vec3(element.aabbMaxX, element.aabbMaxY, element.aabbMaxZ);

    // calculate center
    vec3 center = (aabbMin + 0.5 * (aabbMax - aabbMin)).xyz;
    // map to unit cube
    vec3 g_min = vec3(g_min_x, g_min_y, g_min_z);
    vec3 g_max = vec3(g_max_x, g_max_y, g_max_z);
    vec3 mappedCenter = (center - g_min) / (g_max - g_min);
    // assign morton code
    g_morton_codes[gID] = MortonCodeElement(morton3D(mappedCenter.x, mappedCenter.y, mappedCenter.z), gID);
}